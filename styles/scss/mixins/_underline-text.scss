///  This mixin has 2 possible way of using it.
///  First is to include in the class you want to hover over while text
///  you want to underline needs to have attached class .underline-text
///  or you can send your custom class name via parameter $element.
///  Also you have to set $wrapper parameter to true.
///  Second is to just include it in whichever element you want. In this
///  case, parameter $wrapper should stay unchanged.
///  Other parameters are optional and they allow you customize your transition.
///
/// @access public
/// @author Karlo Volf
/// @param {percentage} $thickness [percentage] - Thickness of the line in percentage.
/// @param {seconds} $duration [s] - How long animation lasts.
/// @param {timing-function} $timing-function [timing-function] - Execution speed function.
/// @param {string} $color [hex] - Color of the line.
/// @param {pixel} $breakpoint [px] - Minimum width of the element.
/// @param {boolean} $wrapper [bool] - If wrapper is used as hover reference.
/// @param {selector} $element [] - Element on which you want underline.
/// @param {string} $state [string] - The state in which it becomes underline element.
/// @example
/// .test {
///   @include underline-text();
/// }
/// .test2 {
///   @include underline-text(4px, .5s, ease-in, #132031, true, a.link, hover);
/// }
/// @output
/// ```scss
/// .test {
///  display: inline;
///  transition: background-size 0.5s ease-in 0s, background-position 0s step-end 0.5s;
///  text-decoration: none;
///  background-image: linear-gradient(transparent 95%, #132031 95%, #132031 100%);
///  background-repeat: no-repeat;
///  background-position-y: bottom;
///  background-size: 0% 100%;
///   &:hover {
///     background-position-x: right;
///     background-position-y: bottom;
///     background-size: 100% 100%;
///   }
/// }
/// .test2 {
///   text-decoration: none;
///   & a.link {
///     display: inline;
///     transition: background-size 0.5s ease-in 0s, background-position 0s step-end 0.5s;
///     text-decoration: none;
///     background-image: linear-gradient(transparent 95%, #132031 95%, #132031 100%);
///     background-repeat: no-repeat;
///     background-position-y: bottom;
///     background-size: 0% 100%;
///   }
///   &:hover a.link {
///     background-position-x: right;
///     background-position-y: bottom;
///     background-size: 100% 100%;
///   }
/// }
/// ```
///


.test2 {
  text-decoration: none;
  & a.link {
    display: inline;
    transition: background-size 0.5s ease-in 0s, background-position 0s step-end 0.5s;
    text-decoration: none;
    background-image: linear-gradient(transparent 95%, #132031 95%, #132031 100%);
    background-repeat: no-repeat;
    background-position-y: bottom;
    background-size: 0% 100%;
  }
  &:hover a.link {
    background-position-x: right;
    background-position-y: bottom;
    background-size: 100% 100%;
  }
}

@mixin underline-text($thickness: 10%, $duration: .5s, $timing-function: cubic-bezier(.79, .01, .22, .99), $color: currentColor, $wrapper: false, $element: '.underline-text', $state: 'hover') {
  $thickness: 100% - $thickness;

  $underline-inactive-state: (
    display: inline,

    transition: (background-size $duration $timing-function 0s, background-position 0s step-end $duration),
    text-decoration: none,

    background-image: linear-gradient(
      transparent $thickness,
      $color $thickness,
      $color 100%
    ),
    background-repeat: no-repeat,
    background-position-y: bottom,
    background-size: 0% 100%,
  );

  $underline-active-state: (
    background-position-x: right,
    background-position-y: bottom,
    background-size: 100% 100%,
  );

  @if $wrapper {
    text-decoration: none;

    #{$element} {
      @include for-each-attribute($underline-inactive-state);
    }

    &:#{$state} {
      #{$element} {
        @include for-each-attribute($underline-active-state);
      }
    }
  } @else {
    @include for-each-attribute($underline-inactive-state);

    &:#{$state} {
      @include for-each-attribute($underline-active-state);
    }
  }
}

@mixin for-each-attribute($map) {
  @each $key, $value in $map {
    #{$key}: #{$value};
  }
}
